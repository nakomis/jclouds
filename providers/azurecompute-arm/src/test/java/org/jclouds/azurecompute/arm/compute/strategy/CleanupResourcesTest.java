/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jclouds.azurecompute.arm.compute.strategy;

import static org.easymock.EasyMock.createMock;
import static org.easymock.EasyMock.expect;
import static org.easymock.EasyMock.replay;
import static org.easymock.EasyMock.verify;
import static org.jclouds.azurecompute.arm.compute.AzureComputeServiceAdapter.AUTOGENERATED_IP_KEY;

import java.net.URI;
import java.util.List;
import java.util.Map;

import org.jclouds.azurecompute.arm.AzureComputeApi;
import org.jclouds.azurecompute.arm.compute.AzureComputeServiceAdapter;
import org.jclouds.azurecompute.arm.domain.AvailabilitySet;
import org.jclouds.azurecompute.arm.domain.AvailabilitySet.AvailabilitySetProperties;
import org.jclouds.azurecompute.arm.domain.DataDisk;
import org.jclouds.azurecompute.arm.domain.DataDisk.DiskCreateOptionTypes;
import org.jclouds.azurecompute.arm.domain.Disk;
import org.jclouds.azurecompute.arm.domain.IdReference;
import org.jclouds.azurecompute.arm.domain.IpConfiguration;
import org.jclouds.azurecompute.arm.domain.IpConfigurationProperties;
import org.jclouds.azurecompute.arm.domain.ManagedDiskParameters;
import org.jclouds.azurecompute.arm.domain.NetworkInterfaceCard;
import org.jclouds.azurecompute.arm.domain.NetworkInterfaceCardProperties;
import org.jclouds.azurecompute.arm.domain.NetworkProfile;
import org.jclouds.azurecompute.arm.domain.NetworkProfile.NetworkInterface;
import org.jclouds.azurecompute.arm.domain.NetworkProfile.NetworkInterface.NetworkInterfaceProperties;
import org.jclouds.azurecompute.arm.domain.NetworkSecurityGroup;
import org.jclouds.azurecompute.arm.domain.NetworkSecurityGroupProperties;
import org.jclouds.azurecompute.arm.domain.OSDisk;
import org.jclouds.azurecompute.arm.domain.PublicIPAddress;
import org.jclouds.azurecompute.arm.domain.PublicIPAddressProperties;
import org.jclouds.azurecompute.arm.domain.Resource;
import org.jclouds.azurecompute.arm.domain.StorageProfile;
import org.jclouds.azurecompute.arm.domain.VirtualMachine;
import org.jclouds.azurecompute.arm.domain.VirtualMachineProperties;
import org.jclouds.azurecompute.arm.features.AvailabilitySetApi;
import org.jclouds.azurecompute.arm.features.DiskApi;
import org.jclouds.azurecompute.arm.features.NetworkInterfaceCardApi;
import org.jclouds.azurecompute.arm.features.NetworkSecurityGroupApi;
import org.jclouds.azurecompute.arm.features.PublicIPAddressApi;
import org.jclouds.azurecompute.arm.features.ResourceGroupApi;
import org.jclouds.compute.functions.GroupNamingConvention;
import org.testng.annotations.Test;

import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;

@Test(groups = "unit", testName = "CleanupResourcesTest")
public class CleanupResourcesTest {

    public void testCleanupVirtualMachineNICs() {
        VirtualMachine vm = mockVmWithNic("prefix/resourceGroups/myGroupName/myNicName");
        NetworkInterfaceCard nic = mockNic("prefix/resourceGroups/myGroupName/myIpAddress");
        PublicIPAddress ipAddress = mockPublicIpAddress(ImmutableMap.of(AUTOGENERATED_IP_KEY, "true"));

        AzureComputeApi api = createMock(AzureComputeApi.class);
        NetworkInterfaceCardApi networkInterfaceCardApi = createMock(NetworkInterfaceCardApi.class);
        PublicIPAddressApi publicIpAddressApi = createMock(PublicIPAddressApi.class);

        expect(api.getNetworkInterfaceCardApi("myGroupName")).andReturn(networkInterfaceCardApi).atLeastOnce();
        expect(api.getPublicIPAddressApi("myGroupName")).andReturn(publicIpAddressApi).atLeastOnce();

        expect(networkInterfaceCardApi.get("myNicName")).andReturn(nic);
        expect(networkInterfaceCardApi.delete("myNicName")).andReturn(URI.create("http://myDeletionUri"));

        expect(publicIpAddressApi.get("myIpAddress")).andReturn(ipAddress);
        expect(publicIpAddressApi.delete("myIpAddress")).andReturn(true);

        replay(api, networkInterfaceCardApi, publicIpAddressApi);

        // Do call
        cleanupResources(api).cleanupVirtualMachineNICs(vm);

        // Verify deleted NIC and IP
        verify(api, networkInterfaceCardApi, publicIpAddressApi);
    }

    public void testCleanupSecurityGroupIfOrphaned() {
        NetworkSecurityGroup networkSecurityGroup = mockNetworkSecurityGroup();

        AzureComputeApi api = createMock(AzureComputeApi.class);
        NetworkSecurityGroupApi networkSecurityGroupApi = createMock(NetworkSecurityGroupApi.class);

        expect(api.getNetworkSecurityGroupApi("myGroupName")).andReturn(networkSecurityGroupApi).atLeastOnce();

        expect(networkSecurityGroupApi.get("myJcloudsGroup")).andReturn(networkSecurityGroup);
        expect(networkSecurityGroupApi.delete("myJcloudsGroup")).andReturn(URI.create("http://myDeletionUri"));

        replay(api, networkSecurityGroupApi);

        // Do call
        cleanupResources(api).cleanupSecurityGroupIfOrphaned("myGroupName", "myJcloudsGroup");

        // Verify deleted security group
        verify(api, networkSecurityGroupApi);
    }

    public void testCleanupAvailabilitySetIfOrphaned() {
        IdReference availabilitySetRef = IdReference.create("prefix/resourceGroups/myGroupName/myAvailabilitySet");
        VirtualMachine vm = mockVmWithAvailabilitySet(availabilitySetRef);
        AvailabilitySet availabilitySet = mockAvailabilitySet(ImmutableMap.of("jclouds", "myval"));

        AzureComputeApi api = createMock(AzureComputeApi.class);
        AvailabilitySetApi availabilitySetApi = createMock(AvailabilitySetApi.class);

        expect(api.getAvailabilitySetApi("myGroupName")).andReturn(availabilitySetApi).atLeastOnce();

        expect(availabilitySetApi.get("myAvailabilitySet")).andReturn(availabilitySet);
        expect(availabilitySetApi.delete("myAvailabilitySet")).andReturn(URI.create("http://myDeletionUri"));

        replay(api, availabilitySetApi);

        // Do call
        cleanupResources(api).cleanupAvailabilitySetIfOrphaned(vm);

        // Verify deleted availability set
        verify(api, availabilitySetApi);
    }

    public void testDeleteResourceGroupIfEmpty() {
        AzureComputeApi api = createMock(AzureComputeApi.class);
        ResourceGroupApi resourceGroupApi = createMock(ResourceGroupApi.class);

        expect(api.getResourceGroupApi()).andReturn(resourceGroupApi).atLeastOnce();

        expect(resourceGroupApi.resources("myGroupName")).andReturn(ImmutableList.<Resource>of());
        expect(resourceGroupApi.delete("myGroupName")).andReturn(URI.create("http://myDeletionUri"));

        replay(api, resourceGroupApi);

        // Do call
        cleanupResources(api).deleteResourceGroupIfEmpty("myGroupName");

        // Verify deleted resource group
        verify(api, resourceGroupApi);
    }

    public void testCleanupManagedDisks() {
        OSDisk osDisk = mockOsDisk("prefix/resourceGroups/myGroupName/myOsDisk");
        DataDisk dataDisk = mockDataDisk("prefix/resourceGroups/myGroupName/myDataDisk");
        VirtualMachine vm = mockVmWithDisks(osDisk, ImmutableList.of(dataDisk));

        AzureComputeApi api = createMock(AzureComputeApi.class);
        DiskApi diskApi = createMock(DiskApi.class);
        Disk disk = createMock(Disk.class);

        expect(api.getDiskApi("myGroupName")).andReturn(diskApi).atLeastOnce();

        expect(diskApi.delete("myOsDisk")).andReturn(URI.create("http://myDeletionUri"));
        expect(diskApi.delete("myDataDisk")).andReturn(URI.create("http://myDeletionUri"));
        // Simulate a delay in disk deletion
        expect(diskApi.get("myDataDisk")).andReturn(disk).times(3);
        expect(diskApi.get("myDataDisk")).andReturn(null).times(2); // An additional call is made when filtering the set
        expect(diskApi.get("myOsDisk")).andReturn(null);

        replay(api, diskApi);

        // Do call
        cleanupResources(api).cleanupManagedDisks(vm);

        // Verify deleted resource group
        verify(api, diskApi);
    }

    private static OSDisk mockOsDisk(String id) {
        ManagedDiskParameters parameters = ManagedDiskParameters.create(id, "myStorageAccountType");
        return OSDisk.builder().managedDiskParameters(parameters).build();
    }

    private static DataDisk mockDataDisk(String id) {
        ManagedDiskParameters parameters = ManagedDiskParameters.create(id, "myStorageAccountType");
        return DataDisk.builder().managedDiskParameters(parameters).createOption(DiskCreateOptionTypes.EMPTY).build();
    }

    private static AvailabilitySet mockAvailabilitySet(Map<String, String> tags) {
        AvailabilitySetProperties properties = AvailabilitySetProperties.builder()
                .virtualMachines(ImmutableList.<IdReference>of())
                .platformUpdateDomainCount(0).platformFaultDomainCount(0)
                .build();
        return AvailabilitySet.classic().tags(tags).properties(properties).build();
    }

    private static NetworkSecurityGroup mockNetworkSecurityGroup() {
        NetworkSecurityGroupProperties properties = NetworkSecurityGroupProperties.builder().build();
        return NetworkSecurityGroup.create("id", "name", null, null, properties, null);
    }

    private static NetworkInterfaceCard mockNic(String... publicIpIdRefs) {
        List<IpConfiguration> ipConfigurations = Lists.newArrayList();
        for (String idRef : publicIpIdRefs) {
            IpConfigurationProperties properties = IpConfigurationProperties.builder()
                    .publicIPAddress(IdReference.create(idRef)).build();
            ipConfigurations.add(IpConfiguration.builder().name("name").id("id").etag("etag").properties(properties).build());
        }

        NetworkInterfaceCardProperties properties = NetworkInterfaceCardProperties.builder()
                .ipConfigurations(ipConfigurations)
                .build();
        Map<String, String> tags = ImmutableMap.of(AzureComputeServiceAdapter.AUTOGENERATED_IP_KEY, "true");

        return NetworkInterfaceCard.create("name", "id", "etag", "location", properties, tags);
    }

    private static PublicIPAddress mockPublicIpAddress(Map<String, String> tags) {
        return PublicIPAddress.builder()
                .name("name").id("id").etag("etag").location("location")
                .tags(tags)
                .properties(PublicIPAddressProperties.builder().publicIPAllocationMethod("publicIPAllocationMethod").build())
                .build();
    }

    private static VirtualMachine mockVmWithNic(String... networkInterfaceIds) {
        List<NetworkInterface> networkInterfaces = Lists.newArrayList();
        for (String id : networkInterfaceIds) {
            networkInterfaces.add(NetworkInterface.create(id, NetworkInterfaceProperties.create(true)));
        }

        return mockVm(networkInterfaces, (IdReference) null, (StorageProfile) null);
    }

    private static VirtualMachine mockVmWithAvailabilitySet(IdReference availabilitySet) {
        return mockVm(ImmutableList.<NetworkInterface>of(), availabilitySet, (StorageProfile) null);
    }

    private VirtualMachine mockVmWithDisks(OSDisk osDisk, ImmutableList<DataDisk> dataDisks) {
        StorageProfile storageProfile = StorageProfile.builder()
                .osDisk(osDisk)
                .dataDisks(dataDisks)
                .build();

        return mockVm(ImmutableList.<NetworkInterface>of(), (IdReference) null, storageProfile);
    }

    private static VirtualMachine mockVm(List<NetworkInterface> networkInterfaces, IdReference availabilitySet, StorageProfile storageProfile) {
        return VirtualMachine.builder()
                .name("name").id("id").type("type").location("location")
                .properties(VirtualMachineProperties.builder()
                        .networkProfile(NetworkProfile.builder().networkInterfaces(networkInterfaces).build())
                        .availabilitySet(availabilitySet)
                        .storageProfile(storageProfile)
                        .build())
                .build();
    }

    private static CleanupResources cleanupResources(AzureComputeApi api) {
        Predicate<URI> resourceDeleted = Predicates.alwaysTrue();
        GroupNamingConvention.Factory namingConvention = new MockGroupNamingConventionFactory();
        Predicate<IdReference> resourceRemoved = Predicates.alwaysTrue();
        return new CleanupResources(api, resourceDeleted, namingConvention, resourceRemoved);
    }

    static class MockGroupNamingConventionFactory implements GroupNamingConvention.Factory {
        @Override
        public GroupNamingConvention createWithoutPrefix() {
            return new MockGroupNamingConvention();
        }
        @Override
        public GroupNamingConvention create() {
            return new MockGroupNamingConvention();
        }
    };

    static class MockGroupNamingConvention implements GroupNamingConvention {
        @Override
        public String sharedNameForGroup(final String group) {
            return group;
        }
        @Override
        public String uniqueNameForGroup(final String group) {
            throw new UnsupportedOperationException();
        }
        @Override
        public String groupInUniqueNameOrNull(final String encoded) {
            throw new UnsupportedOperationException();
        }
        @Override
        public String groupInSharedNameOrNull(final String encoded) {
            throw new UnsupportedOperationException();
        }
        @Override
        public Predicate<String> containsGroup(final String group) {
            throw new UnsupportedOperationException();
        }
        @Override
        public Predicate<String> containsAnyGroup() {
            throw new UnsupportedOperationException();
        }
        @Override
        public String extractGroup(final String encoded) {
            throw new UnsupportedOperationException();
        }
    }
}
